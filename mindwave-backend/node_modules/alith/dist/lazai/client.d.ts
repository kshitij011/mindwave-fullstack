import { ChainConfig, ChainManager } from "./chain";
import { ContractConfig } from "./contracts";
import type { ProofData, SettlementData } from "./proof";
export declare class Client extends ChainManager {
    contractConfig: ContractConfig;
    constructor(chainConfig?: ChainConfig, contractConfig?: ContractConfig, privateKey?: string);
    dataRegistryContract(): import("web3").Contract<({
        constant: boolean;
        inputs: never[];
        name: string;
        outputs: {
            name: string;
            type: string;
        }[];
        payable: boolean;
        stateMutability: string;
        type: string;
    } | {
        inputs: ({
            name: string;
            type: string;
            components?: undefined;
        } | {
            components: {
                name: string;
                type: string;
            }[];
            name: string;
            type: string;
        })[];
        name: string;
        outputs: {
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        constant?: undefined;
        payable?: undefined;
    } | {
        constant: boolean;
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            components: {
                name: string;
                type: string;
            }[];
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        payable?: undefined;
    } | {
        constant: boolean;
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        payable?: undefined;
    } | {
        inputs: ({
            internalType: string;
            name: string;
            type: string;
            components?: undefined;
        } | {
            components: ({
                internalType: string;
                name: string;
                type: string;
                components?: undefined;
            } | {
                components: {
                    internalType: string;
                    name: string;
                    type: string;
                }[];
                internalType: string;
                name: string;
                type: string;
            })[];
            internalType: string;
            name: string;
            type: string;
        })[];
        name: string;
        outputs: never[];
        stateMutability: string;
        type: string;
        constant?: undefined;
        payable?: undefined;
    })[]>;
    verifiedComputingContract(): import("web3").Contract<({
        type: string;
        name: string;
        inputs: {
            name: string;
            type: string;
        }[];
        components?: undefined;
        outputs?: undefined;
        stateMutability?: undefined;
        constant?: undefined;
    } | {
        type: string;
        name: string;
        components: {
            name: string;
            type: string;
        }[];
        inputs?: undefined;
        outputs?: undefined;
        stateMutability?: undefined;
        constant?: undefined;
    } | {
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: never[];
        stateMutability: string;
        type: string; /**
         * Mint a new Data Anchor Token (DAT) with the specified parameters.
         */
        components?: undefined;
        constant?: undefined;
    } | {
        constant: boolean;
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            components: {
                name: string;
                type: string;
            }[];
            type: string;
        }[];
        stateMutability: string;
        type: string;
        components?: undefined;
    } | {
        constant: boolean;
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        components?: undefined;
    })[]>;
    dataAnchoringTokenContract(): import("web3").Contract<({
        type: string;
        name: string;
        inputs: {
            name: string;
            type: string;
        }[];
        components?: undefined;
        outputs?: undefined;
        stateMutability?: undefined;
        constant?: undefined;
    } | {
        type: string;
        name: string;
        components: {
            name: string;
            type: string;
        }[];
        inputs?: undefined;
        outputs?: undefined;
        stateMutability?: undefined;
        constant?: undefined;
    } | {
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: never[];
        stateMutability: string;
        type: string; /**
         * Mint a new Data Anchor Token (DAT) with the specified parameters.
         */
        components?: undefined;
        constant?: undefined;
    } | {
        constant: boolean;
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            components: {
                name: string;
                type: string;
            }[];
            type: string;
        }[];
        stateMutability: string;
        type: string;
        components?: undefined;
    } | {
        constant: boolean;
        inputs: {
            name: string;
            type: string;
        }[];
        name: string;
        outputs: {
            name: string;
            type: string;
        }[];
        stateMutability: string;
        type: string;
        components?: undefined;
    })[]>;
    queryContract(): import("web3").Contract<({
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
            components: ({
                type: string;
                name: string;
                components?: undefined;
            } | {
                type: string;
                name: string;
                components: {
                    type: string;
                    name: string;
                }[];
            })[];
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
            name: string;
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
            components: ({
                type: string;
                name: string;
                components?: undefined;
            } | {
                type: string;
                name: string;
                components: {
                    type: string;
                    name: string;
                }[];
            })[];
        }[];
        outputs: never[];
        stateMutability: string;
    })[]>;
    inferenceContract(): import("web3").Contract<({
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
            components: ({
                type: string;
                name: string;
                components?: undefined;
            } | {
                type: string;
                name: string;
                components: {
                    type: string;
                    name: string;
                }[];
            })[];
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
            name: string;
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
            components: ({
                type: string;
                name: string;
                components?: undefined;
            } | {
                type: string;
                name: string;
                components: {
                    type: string;
                    name: string;
                }[];
            })[];
        }[];
        outputs: never[];
        stateMutability: string;
    })[]>;
    trainingContract(): import("web3").Contract<({
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
            components: ({
                type: string;
                name: string;
                components?: undefined;
            } | {
                type: string;
                name: string;
                components: {
                    type: string;
                    name: string;
                }[];
            })[];
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
            name: string;
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
            components: ({
                type: string;
                name: string;
                components?: undefined;
            } | {
                type: string;
                name: string;
                components: {
                    type: string;
                    name: string;
                }[];
            })[];
        }[];
        outputs: never[];
        stateMutability: string;
    })[]>;
    settlementContract(): import("web3").Contract<({
        type: string;
        name: string;
        inputs: never[];
        outputs: {
            type: string;
        }[];
        stateMutability: string;
    } | {
        type: string;
        name: string;
        inputs: {
            type: string;
            name: string;
        }[];
        outputs: {
            type: string;
            components: {
                type: string;
                name: string;
            }[];
        }[];
        stateMutability: string;
    })[]>;
    getWallet(): import("web3").Web3Account;
    getPublicKey(): Promise<string>;
    addFile(url: string): Promise<bigint>;
    addFileWithHash(url: string, hash: string): Promise<bigint>;
    getFileIdByUrl(url: string): Promise<bigint>;
    addNode(address: string, url: string, publicKey: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    addProof(fileId: bigint, data: ProofData): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    addFileWithPermissions(url: string, ownerAddress: string, permissions: {
        account: string;
        key: string;
    }[]): Promise<bigint>;
    addPermissionForFile(fileId: bigint, account: string, key: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    getFile(fileId: bigint): Promise<{
        id: bigint;
        url: string;
        owner: string;
        createdAt: bigint;
    }>;
    getFilePermission(fileId: bigint, account: string): Promise<string>;
    getFileProof(fileId: bigint, index: bigint): Promise<{
        signature: string;
        data: {
            id: bigint;
            fileUrl: string;
            proofUrl: string;
        };
    }>;
    getFilesCount(): Promise<bigint>;
    requestReward(fileId: bigint, proofIndex?: bigint): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    removeNode(address: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    nodeList(): Promise<string[]>;
    getNode(address: string): Promise<{
        nodeAddress: string;
        url: string;
        status: number;
        amount: string;
        jobsCount: bigint;
        publicKey: string;
    }>;
    updateNodeFee(fee: bigint): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    nodeFee(): Promise<bigint>;
    requestProof(fileId: bigint, value?: bigint): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    completeJob(jobId: bigint): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    getJob(jobId: bigint): Promise<{
        fileId: bigint;
        bidAmount: string;
        status: number;
        addedTimestamp: bigint;
        ownerAddress: string;
        nodeAddress: string;
    }>;
    fileJobIds(fileId: bigint): Promise<bigint[]>;
    jobsCount(): Promise<bigint>;
    nodeListAt(index: bigint): Promise<{
        nodeAddress: string;
        url: string;
        status: number;
        amount: string;
        jobsCount: bigint;
        publicKey: string;
    }>;
    activeNodeList(): Promise<string[]>;
    activeNodeListAt(index: bigint): Promise<{
        nodeAddress: string;
        url: string;
        status: number;
        amount: string;
        jobsCount: bigint;
        publicKey: string;
    }>;
    nodesCount(): Promise<bigint>;
    activeNodesCount(): Promise<bigint>;
    isNode(address: string): Promise<boolean>;
    submitJob(fileId: bigint, value: bigint): Promise<void>;
    claim(): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    /**
     * Mint a new Data Anchor Token (DAT) with the specified parameters.
     */
    mintDAT(): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    /**
     * Returns the balance of a specific Data Anchor Token (DAT) for a given account and token ID.
     */
    getDATBalance(account: string, id: bigint): Promise<bigint>;
    /**
     * Returns the Uri for a specific Data Anchor Token (DAT) by its token ID.
     */
    dataUri(tokenId: bigint): Promise<string>;
    getUser(address: string): Promise<{
        addr: string;
        availableBalance: bigint;
        totalBalance: bigint;
        queryNodes: string[];
        inferenceNodes: string[];
        trainingNodes: string[];
    }>;
    getAllUsers(): Promise<{
        addr: string;
        availableBalance: bigint;
        totalBalance: bigint;
        inferenceNodes: string[];
        trainingNodes: string[];
    }[]>;
    addUser(amount: number | string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    deleteUser(): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    deposit(amount: number | string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    withdraw(amount: number | string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    depositQuery(node: string, amount: number): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    depositInference(node: string, amount: number): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    depositTraining(node: string, amount: number): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    retrieveQuery(nodes: string[]): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    retrieveInference(nodes: string[]): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    retrieveTraining(nodes: string[]): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    addQueryNode(address: string, url: string, public_key: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    removeQueryNode(address: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    getQueryNode(address: string): Promise<{
        nodeAddress: string;
        url: string;
        status: number;
        amount: string;
        jobsCount: bigint;
        publicKey: string;
    }>;
    queryNodeList(): Promise<string[]>;
    getQueryAccount(user: string, node: string): Promise<{
        user: string;
        node: string;
        nonce: bigint;
        balance: bigint;
        pendingRefund: bigint;
        refunds: {
            index: bigint;
            amount: bigint;
            createdAt: bigint;
            processed: boolean;
        }[];
    }>;
    querySettlementFees(data: SettlementData): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    addInferenceNode(address: string, url: string, public_key: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    removeInferenceNode(address: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    getInferenceNode(address: string): Promise<{
        nodeAddress: string;
        url: string;
        status: number;
        amount: string;
        jobsCount: bigint;
        publicKey: string;
    }>;
    inferenceNodeList(): Promise<string[]>;
    getInferenceAccount(user: string, node: string): Promise<{
        user: string;
        node: string;
        nonce: bigint;
        balance: bigint;
        pendingRefund: bigint;
        refunds: {
            index: bigint;
            amount: bigint;
            createdAt: bigint;
            processed: boolean;
        }[];
    }>;
    inferenceSettlementFees(data: SettlementData): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    addTrainingNode(address: string, url: string, public_key: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    removeTrainingNode(address: string): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    getTrainingNode(address: string): Promise<{
        nodeAddress: string;
        url: string;
        status: number;
        amount: string;
        jobsCount: bigint;
        publicKey: string;
    }>;
    trainingNodeList(): Promise<string[]>;
    getTrainingAccount(user: string, node: string): Promise<{
        user: string;
        node: string;
        nonce: bigint;
        balance: bigint;
        pendingRefund: bigint;
        refunds: {
            index: bigint;
            amount: bigint;
            createdAt: bigint;
            processed: boolean;
        }[];
    }>;
    trainingSettlementFees(data: SettlementData): Promise<{
        transactionHash: import("web3").Bytes;
        receipt: import("web3").TransactionReceipt;
    }>;
    getRequestHeaders(node: string, fileId?: BigInt, nonce?: BigInt): Promise<Record<string, string>>;
    private secureNonce;
}
