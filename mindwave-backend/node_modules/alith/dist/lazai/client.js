"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const chain_1 = require("./chain");
const contracts_1 = require("./contracts");
const crypto_1 = require("crypto");
const web3_1 = __importDefault(require("web3"));
const settlement_1 = require("./settlement");
class Client extends chain_1.ChainManager {
    constructor(chainConfig = chain_1.ChainConfig.testnet(), contractConfig = contracts_1.ContractConfig.testnet(), privateKey = process.env.PRIVATE_KEY || "") {
        super(chainConfig, privateKey);
        this.contractConfig = contractConfig;
    }
    dataRegistryContract() {
        return new this.web3.eth.Contract(contracts_1.DATA_REGISTRY_CONTRACT_ABI, this.contractConfig.dataRegistryAddress);
    }
    verifiedComputingContract() {
        return new this.web3.eth.Contract(contracts_1.VERIFIED_COMPUTING_CONTRACT_ABI, this.contractConfig.verifiedComputingAddress);
    }
    dataAnchoringTokenContract() {
        return new this.web3.eth.Contract(contracts_1.VERIFIED_COMPUTING_CONTRACT_ABI, this.contractConfig.dataAnchoringTokenAddress);
    }
    queryContract() {
        return new this.web3.eth.Contract(contracts_1.AI_PROCESS_CONTRACT_ABI, this.contractConfig.queryAddress);
    }
    inferenceContract() {
        return new this.web3.eth.Contract(contracts_1.AI_PROCESS_CONTRACT_ABI, this.contractConfig.inferenceAddress);
    }
    trainingContract() {
        return new this.web3.eth.Contract(contracts_1.AI_PROCESS_CONTRACT_ABI, this.contractConfig.trainingAddress);
    }
    settlementContract() {
        return new this.web3.eth.Contract(contracts_1.SETTLEMENT_CONTRACT_ABI, this.contractConfig.settlementAddress);
    }
    getWallet() {
        return this.account;
    }
    async getPublicKey() {
        return this.dataRegistryContract().methods.publicKey().call();
    }
    async addFile(url) {
        return this.addFileWithHash(url, "");
    }
    async addFileWithHash(url, hash) {
        const method = this.dataRegistryContract().methods.addFile(url, hash);
        await this.sendTransaction(method, this.contractConfig.dataRegistryAddress);
        return this.getFileIdByUrl(url);
    }
    async getFileIdByUrl(url) {
        return this.dataRegistryContract().methods.getFileIdByUrl(url).call();
    }
    async addNode(address, url, publicKey) {
        const method = this.verifiedComputingContract().methods.addNode(address, url, publicKey);
        return await this.sendTransaction(method, this.contractConfig.verifiedComputingAddress);
    }
    async addProof(fileId, data) {
        const messageHash = web3_1.default.utils.keccak256(data.abiEncode());
        const signature = this.web3.eth.accounts.sign(messageHash, this.account.privateKey);
        const proof = {
            signature: signature.signature,
            data: {
                id: data.id,
                score: data.score,
                fileUrl: data.fileUrl,
                proofUrl: data.proofUrl,
            },
        };
        const method = this.dataRegistryContract().methods.addProof(fileId, proof);
        return await this.sendTransaction(method, this.contractConfig.dataRegistryAddress);
    }
    async addFileWithPermissions(url, ownerAddress, permissions) {
        const method = this.dataRegistryContract().methods.addFileWithPermissions(url, ownerAddress, permissions);
        await this.sendTransaction(method, this.contractConfig.dataRegistryAddress);
        return this.getFileIdByUrl(url);
    }
    async addPermissionForFile(fileId, account, key) {
        const method = this.dataRegistryContract().methods.addPermissionForFile(fileId, account, key);
        return await this.sendTransaction(method, this.contractConfig.dataRegistryAddress);
    }
    async getFile(fileId) {
        return this.dataRegistryContract().methods.getFile(fileId).call();
    }
    async getFilePermission(fileId, account) {
        return this.dataRegistryContract()
            .methods.getFilePermission(fileId, account)
            .call();
    }
    async getFileProof(fileId, index) {
        return this.dataRegistryContract()
            .methods.getFileProof(fileId, index)
            .call();
    }
    async getFilesCount() {
        return this.dataRegistryContract().methods.filesCount().call();
    }
    async requestReward(fileId, proofIndex = BigInt(1)) {
        const method = this.dataRegistryContract().methods.requestReward(fileId, proofIndex);
        return await this.sendTransaction(method, this.contractConfig.dataRegistryAddress);
    }
    async removeNode(address) {
        const method = this.verifiedComputingContract().methods.removeNode(address);
        return await this.sendTransaction(method, this.contractConfig.verifiedComputingAddress);
    }
    async nodeList() {
        return this.verifiedComputingContract().methods.nodeList().call();
    }
    async getNode(address) {
        return this.verifiedComputingContract().methods.getNode(address).call();
    }
    async updateNodeFee(fee) {
        const method = this.verifiedComputingContract().methods.updateNodeFee(fee);
        return await this.sendTransaction(method, this.contractConfig.verifiedComputingAddress);
    }
    async nodeFee() {
        return this.verifiedComputingContract().methods.nodeFee().call();
    }
    async requestProof(fileId, value = BigInt(0)) {
        const method = this.verifiedComputingContract().methods.requestProof(fileId);
        return await this.sendTransaction(method, this.contractConfig.verifiedComputingAddress, value.toString());
    }
    async completeJob(jobId) {
        const method = this.verifiedComputingContract().methods.completeJob(jobId);
        return await this.sendTransaction(method, this.contractConfig.verifiedComputingAddress);
    }
    async getJob(jobId) {
        return this.verifiedComputingContract().methods.getJob(jobId).call();
    }
    async fileJobIds(fileId) {
        return this.verifiedComputingContract().methods.fileJobIds(fileId).call();
    }
    async jobsCount() {
        return this.verifiedComputingContract().methods.jobsCount().call();
    }
    async nodeListAt(index) {
        return this.verifiedComputingContract().methods.nodeListAt(index).call();
    }
    async activeNodeList() {
        return this.verifiedComputingContract().methods.activeNodeList().call();
    }
    async activeNodeListAt(index) {
        return this.verifiedComputingContract()
            .methods.activeNodeListAt(index)
            .call();
    }
    async nodesCount() {
        return this.verifiedComputingContract().methods.nodesCount().call();
    }
    async activeNodesCount() {
        return this.verifiedComputingContract().methods.activeNodesCount().call();
    }
    async isNode(address) {
        return this.verifiedComputingContract().methods.isNode(address).call();
    }
    async submitJob(fileId, value) {
        const method = this.verifiedComputingContract().methods.submitJob(fileId);
        await this.sendTransaction(method, this.contractConfig.verifiedComputingAddress, value.toString());
    }
    async claim() {
        const method = this.verifiedComputingContract().methods.claim();
        return await this.sendTransaction(method, this.contractConfig.verifiedComputingAddress);
    }
    /**
     * Mint a new Data Anchor Token (DAT) with the specified parameters.
     */
    async mintDAT() {
        const method = this.dataAnchoringTokenContract().methods.mint;
        return await this.sendTransaction(method, this.contractConfig.dataAnchoringTokenAddress);
    }
    /**
     * Returns the balance of a specific Data Anchor Token (DAT) for a given account and token ID.
     */
    async getDATBalance(account, id) {
        return this.dataAnchoringTokenContract()
            .methods.balanceOf(account, id)
            .call();
    }
    /**
     * Returns the Uri for a specific Data Anchor Token (DAT) by its token ID.
     */
    async dataUri(tokenId) {
        return this.dataAnchoringTokenContract().methods.uri(tokenId).call();
    }
    async getUser(address) {
        return this.settlementContract().methods.getUser(address).call();
    }
    async getAllUsers() {
        return this.settlementContract().methods.getAllUser().call();
    }
    async addUser(amount) {
        const method = this.settlementContract().methods.addUser();
        return await this.sendTransaction(method, this.contractConfig.settlementAddress, amount);
    }
    async deleteUser() {
        const method = this.settlementContract().methods.deleteUser();
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async deposit(amount) {
        const method = this.settlementContract().methods.deposit();
        return await this.sendTransaction(method, this.contractConfig.settlementAddress, amount);
    }
    async withdraw(amount) {
        const method = this.settlementContract().methods.withdraw(amount);
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async depositQuery(node, amount) {
        const method = this.settlementContract().methods.depositQuery(node, amount);
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async depositInference(node, amount) {
        const method = this.settlementContract().methods.depositInference(node, amount);
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async depositTraining(node, amount) {
        const method = this.settlementContract().methods.depositTraining(node, amount);
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async retrieveQuery(nodes) {
        const method = this.settlementContract().methods.retrieveQuery(nodes);
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async retrieveInference(nodes) {
        const method = this.settlementContract().methods.retrieveInference(nodes);
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async retrieveTraining(nodes) {
        const method = this.settlementContract().methods.retrieveTraining(nodes);
        return await this.sendTransaction(method, this.contractConfig.settlementAddress);
    }
    async addQueryNode(address, url, public_key) {
        const method = this.queryContract().methods.addNode(address, url, public_key);
        return await this.sendTransaction(method, this.contractConfig.queryAddress);
    }
    async removeQueryNode(address) {
        const method = this.queryContract().methods.removeNode(address);
        return await this.sendTransaction(method, this.contractConfig.queryAddress);
    }
    async getQueryNode(address) {
        return this.queryContract().methods.getNode(address).call();
    }
    async queryNodeList() {
        return this.queryContract().methods.nodeList().call();
    }
    async getQueryAccount(user, node) {
        return this.queryContract().methods.getAccount(user, node).call();
    }
    async querySettlementFees(data) {
        const messageHash = web3_1.default.utils.keccak256(data.abiEncode());
        const signature = this.web3.eth.accounts.sign(messageHash, this.account.privateKey);
        const settlement = {
            signature: signature.signature,
            data: {
                id: data.id,
                user: data.user,
                cost: data.cost,
                nonce: data.nonce,
                userSignature: data.userSignature,
            },
        };
        const method = this.queryContract().methods.settlementFees(settlement);
        return await this.sendTransaction(method, this.contractConfig.queryAddress);
    }
    async addInferenceNode(address, url, public_key) {
        const method = this.inferenceContract().methods.addNode(address, url, public_key);
        return await this.sendTransaction(method, this.contractConfig.inferenceAddress);
    }
    async removeInferenceNode(address) {
        const method = this.inferenceContract().methods.removeNode(address);
        return await this.sendTransaction(method, this.contractConfig.inferenceAddress);
    }
    async getInferenceNode(address) {
        return this.inferenceContract().methods.getNode(address).call();
    }
    async inferenceNodeList() {
        return this.inferenceContract().methods.nodeList().call();
    }
    async getInferenceAccount(user, node) {
        return this.inferenceContract().methods.getAccount(user, node).call();
    }
    async inferenceSettlementFees(data) {
        const messageHash = web3_1.default.utils.keccak256(data.abiEncode());
        const signature = this.web3.eth.accounts.sign(messageHash, this.account.privateKey);
        const settlement = {
            signature: signature.signature,
            data: {
                id: data.id,
                user: data.user,
                cost: data.cost,
                nonce: data.nonce,
                userSignature: data.userSignature,
            },
        };
        const method = this.inferenceContract().methods.settlementFees(settlement);
        return await this.sendTransaction(method, this.contractConfig.inferenceAddress);
    }
    async addTrainingNode(address, url, public_key) {
        const method = this.trainingContract().methods.addNode(address, url, public_key);
        return await this.sendTransaction(method, this.contractConfig.trainingAddress);
    }
    async removeTrainingNode(address) {
        const method = this.trainingContract().methods.removeNode(address);
        return await this.sendTransaction(method, this.contractConfig.trainingAddress);
    }
    async getTrainingNode(address) {
        return this.trainingContract().methods.getNode(address).call();
    }
    async trainingNodeList() {
        return this.trainingContract().methods.nodeList().call();
    }
    async getTrainingAccount(user, node) {
        return this.trainingContract().methods.getAccount(user, node).call();
    }
    async trainingSettlementFees(data) {
        const messageHash = web3_1.default.utils.keccak256(data.abiEncode());
        const signature = this.web3.eth.accounts.sign(messageHash, this.account.privateKey);
        const settlement = {
            signature: signature.signature,
            data: {
                id: data.id,
                user: data.user,
                cost: data.cost,
                nonce: data.nonce,
                userSignature: data.userSignature,
            },
        };
        const method = this.trainingContract().methods.settlementFees(settlement);
        return await this.sendTransaction(method, this.contractConfig.trainingAddress);
    }
    async getRequestHeaders(node, fileId, nonce) {
        const generatedNonce = nonce ?? this.secureNonce();
        const request = new settlement_1.SettlementRequest(generatedNonce, this.getWallet().address, node, fileId);
        const signature = request.generateSignature(this.getWallet().privateKey);
        return signature.toRequestHeaders();
    }
    secureNonce() {
        const timestampMs = Date.now();
        const randomBytesBuffer = (0, crypto_1.randomBytes)(4);
        const randomInt = randomBytesBuffer.readUInt32BE(0);
        const randomPart = randomInt % 100000;
        return BigInt(timestampMs) * BigInt(100000) + BigInt(randomPart);
    }
}
exports.Client = Client;
