"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverAddress = exports.validateAccountAndSignature = exports.validateRequest = exports.TRAINING_TYPE = exports.INFERENCE_TYPE = exports.QUERY_TYPE = exports.FILE_ID_HEADER = exports.TOKEN_ID_HEADER = exports.SIGNATURE_HEADER = exports.NONCE_HEADER = exports.USER_HEADER = void 0;
const web3_1 = __importDefault(require("web3"));
exports.USER_HEADER = "X-LazAI-User";
exports.NONCE_HEADER = "X-LazAI-Nonce";
exports.SIGNATURE_HEADER = "X-LazAI-Signature";
exports.TOKEN_ID_HEADER = "X-LazAI-Token-ID";
exports.FILE_ID_HEADER = "X-LazAI-File-ID";
exports.QUERY_TYPE = 0;
exports.INFERENCE_TYPE = 1;
exports.TRAINING_TYPE = 2;
const client_1 = require("./client");
async function validateRequest(headers, type = exports.QUERY_TYPE, client) {
    const user = headers[exports.USER_HEADER];
    const nonce = headers[exports.NONCE_HEADER];
    const signature = headers[exports.SIGNATURE_HEADER];
    await validateAccountAndSignature(user, parseInt(nonce), signature, type, client);
}
exports.validateRequest = validateRequest;
async function validateAccountAndSignature(user, nonce, signature, type = exports.TRAINING_TYPE, client) {
    const clientInstance = client || new client_1.Client();
    const node = clientInstance.getWallet().address;
    let account = null;
    if (type === exports.TRAINING_TYPE) {
        account = await clientInstance.getTrainingAccount(user, node);
    }
    else if (type === exports.INFERENCE_TYPE) {
        account = await clientInstance.getInferenceAccount(user, node);
    }
    else {
        account = await clientInstance.getQueryAccount(user, node);
    }
    if (!account || account.node !== user) {
        throw new Error(`Account ${user} does not exist or is unauthorized`);
    }
    const lastNonce = account.nonce;
    if (nonce <= lastNonce) {
        throw new Error(`Invalid nonce: ${nonce}. Must be greater than last nonce: ${lastNonce}`);
    }
    const recoveredAddress = recoverAddress(nonce, user, node, signature);
    if (recoveredAddress.toLowerCase() !== user.toLowerCase()) {
        throw new Error("Signature verification failed: address mismatch");
    }
}
exports.validateAccountAndSignature = validateAccountAndSignature;
function recoverAddress(nonce, user, node, signature) {
    const web3 = new web3_1.default();
    const encodedData = web3.eth.abi.encodeParameter("(uint256, address, address)", [nonce, user, node]);
    const messageHash = web3_1.default.utils.keccak256(encodedData);
    const recoveredAddress = web3.eth.accounts.recover(messageHash, signature);
    return recoveredAddress;
}
exports.recoverAddress = recoverAddress;
