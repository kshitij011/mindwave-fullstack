"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainManager = exports.ChainConfig = exports.TESTNET_CHAINID = exports.TESTNET_ENDPOINT = exports.LOCAL_CHAIN_ENDPOINT = exports.TESTNET_NETWORK = exports.DEVNET_NETWORK = void 0;
const async_mutex_1 = require("async-mutex");
const web3_1 = require("web3");
exports.DEVNET_NETWORK = "LazAI Devnet";
exports.TESTNET_NETWORK = "LazAI Testnet";
exports.LOCAL_CHAIN_ENDPOINT = "http://localhost:8545";
exports.TESTNET_ENDPOINT = "https://lazai-testnet.metisdevops.link";
exports.TESTNET_CHAINID = 133718;
class ChainConfig {
    constructor(network, endpoint, chainId) {
        this.network = network;
        this.endpoint = endpoint;
        this.chainId = chainId;
        this.gasMultiplier = 1.5;
        this.maxRetries = 3;
    }
    static local() {
        return new ChainConfig(exports.DEVNET_NETWORK, exports.LOCAL_CHAIN_ENDPOINT, exports.TESTNET_CHAINID);
    }
    static testnet() {
        return new ChainConfig(exports.TESTNET_NETWORK, exports.TESTNET_ENDPOINT, exports.TESTNET_CHAINID);
    }
}
exports.ChainConfig = ChainConfig;
class ChainManager {
    constructor(config = ChainConfig.testnet(), privateKey = process.env.PRIVATE_KEY || "") {
        this.nonceMutex = new async_mutex_1.Mutex();
        this.config = config;
        this.web3 = new web3_1.Web3(config.endpoint);
        this.account = this.web3.eth.accounts.privateKeyToAccount(privateKey);
    }
    async getCurrentBlock() {
        return this.web3.eth.getBlockNumber();
    }
    async getBalance(address) {
        return this.web3.eth.getBalance(address || this.account.address);
    }
    async getNonce(address) {
        return this.web3.eth.getTransactionCount(address || this.account.address, "pending");
    }
    async getGasPrice() {
        return this.web3.eth.getGasPrice();
    }
    async sendTransaction(contractMethod, to, value = 0, maxRetries = 3) {
        return this.nonceMutex.runExclusive(async () => {
            let retries = 0;
            while (retries < maxRetries) {
                try {
                    const nonce = await this.getNonce();
                    const gasEstimate = await contractMethod.estimateGas({
                        from: this.account.address,
                        value,
                    });
                    const gasPrice = await this.getGasPrice();
                    const tx = {
                        from: this.account.address,
                        to: to,
                        data: contractMethod.encodeABI(),
                        gas: Math.round(Number(gasEstimate) * 1.2),
                        gasPrice,
                        nonce,
                        value,
                        chainId: this.config.chainId,
                    };
                    const signedTx = await this.account.signTransaction(tx);
                    const receipt = await this.web3.eth.sendSignedTransaction(signedTx.rawTransaction);
                    return {
                        transactionHash: receipt.transactionHash,
                        receipt,
                    };
                }
                catch (error) {
                    retries++;
                    if (retries >= maxRetries)
                        throw error;
                    await new Promise((resolve) => setTimeout(resolve, 1000 * retries));
                }
            }
            throw new Error("Transaction failed after maximum retries");
        });
    }
}
exports.ChainManager = ChainManager;
