"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TappdClient = exports.TEEAgent = exports.TEEClient = void 0;
/**
 * Alith Phala TEE Integration & SDK. This SDK provides a Rust client for communicating with the Tappd server,
 * which is available inside Phala Network DStack.
 *
 * For local development without TDX devices, you can use the simulator available for download here:
 * https://github.com/Leechael/tappd-simulator/releases and then set the environment variable `DSTACK_SIMULATOR_ENDPOINT`
 *
 * Leave the endpoint parameter empty for the tappd client in production. You only need to add volumes in your
 * docker-compose file to run Confidential Virtual Machines (CVMs):
 *
 * ```yaml
 *   volumes:
 *   - /var/run/tappd.sock:/var/run/tappd.sock
 * ```
 */
const dstack_sdk_1 = require("@phala/dstack-sdk");
Object.defineProperty(exports, "TappdClient", { enumerable: true, get: function () { return dstack_sdk_1.TappdClient; } });
/**
 * Phala TEE Client for secure AI agent execution
 * Provides TEE-based security guarantees for sensitive AI operations
 */
class TEEClient {
    constructor(config = {}) {
        this.config = {
            endpoint: config.endpoint || "http://localhost:8090",
            enableAttestation: config.enableAttestation ?? true,
            enableKeyDerivation: config.enableKeyDerivation ?? true,
            enableSignatures: config.enableSignatures ?? true,
            timeout: config.timeout ?? 30000,
        };
        // Initialize Phala TappdClient
        this.client = new dstack_sdk_1.TappdClient(this.config.endpoint);
    }
    /**
     * Get TEE environment information
     */
    async getInfo() {
        try {
            return await this.client.info();
        }
        catch (error) {
            throw new Error(`Failed to get TEE info: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Generate remote attestation for the current TEE environment
     * This proves the code is running in a genuine, uncompromised TEE
     */
    async generateAttestation(userData = "", hashAlg = "sha256") {
        try {
            if (!this.config.enableAttestation) {
                throw new Error("Attestation is disabled in configuration");
            }
            // Generate TDX quote using Phala's SDK
            const result = await this.client.tdxQuote(userData, hashAlg);
            // Replay RTMRs for verification
            const rtmrs = result.replayRtmrs();
            return {
                quote: result.quote,
                eventLog: result.event_log,
                rtmrs,
                verified: true, // In production, this should be verified against Intel's attestation service
                timestamp: new Date(),
            };
        }
        catch (error) {
            throw new Error(`Failed to generate attestation: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Derive a cryptographic key within the TEE
     * Keys never leave the secure environment
     */
    async deriveKey(path = "/", userData = "") {
        try {
            if (!this.config.enableKeyDerivation) {
                throw new Error("Key derivation is disabled in configuration");
            }
            // Use Phala's key derivation capability
            const result = await this.client.deriveKey(path, userData);
            return {
                key: result.key,
                certificateChain: result.certificate_chain,
                keyPath: path,
            };
        }
        catch (error) {
            throw new Error(`Failed to derive key: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Execute a function within TEE with cryptographic verification
     * This is the core method for secure AI operations
     */
    async executeSecure(operation, options = {}) {
        try {
            const { attestUserData = `alith-tee-execution-${Date.now()}`, signResult = this.config.enableSignatures, includeAttestation = this.config.enableAttestation, } = options;
            // Generate attestation proof before execution
            let attestation;
            if (includeAttestation) {
                attestation = await this.generateAttestation(attestUserData);
            }
            // Execute the operation within TEE
            const result = await operation();
            // Generate signature if requested
            let signature = "";
            if (signResult) {
                // Create deterministic signature of the result
                const resultHash = this.hashResult(result);
                // In a real implementation, this would use TEE's signing capability
                // For now, we'll create a placeholder signature that includes the attestation
                signature = await this.signWithTEE(resultHash, attestation?.quote || "");
            }
            return {
                result,
                signature,
                attestation,
                verified: true,
            };
        }
        catch (error) {
            throw new Error(`TEE execution failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Verify a TEE execution result
     */
    async verifyExecution(execution) {
        try {
            // Verify signature if present
            if (execution.signature && this.config.enableSignatures) {
                const resultHash = this.hashResult(execution.result);
                const isValidSignature = await this.verifySignature(resultHash, execution.signature, execution.attestation?.quote || "");
                if (!isValidSignature) {
                    return false;
                }
            }
            // Verify attestation if present
            if (execution.attestation && this.config.enableAttestation) {
                // In production, this would verify against Intel's attestation service
                // For now, we'll do basic validation
                return this.verifyAttestation(execution.attestation);
            }
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Create a secure communication channel using TEE-derived keys
     */
    async createSecureChannel() {
        try {
            // Derive a unique key for this channel
            const channelId = `channel-${Date.now()}-${Math.random()
                .toString(36)
                .substr(2, 9)}`;
            const localKey = await this.deriveKey(`/channels/${channelId}`);
            // Simple encryption/decryption functions (in production, use proper crypto)
            const encrypt = (data) => {
                // This is a placeholder - use proper encryption in production
                return Buffer.from(data + localKey.key).toString("base64");
            };
            const decrypt = (data) => {
                // This is a placeholder - use proper decryption in production
                const decoded = Buffer.from(data, "base64").toString();
                return decoded.replace(localKey.key, "");
            };
            return {
                localKey,
                channelId,
                encrypt,
                decrypt,
            };
        }
        catch (error) {
            throw new Error(`Failed to create secure channel: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    // Private helper methods
    hashResult(result) {
        // Simple hash implementation - use proper crypto hash in production
        return Buffer.from(JSON.stringify(result)).toString("base64");
    }
    async signWithTEE(data, attestationQuote) {
        // Placeholder signature - in production, use TEE's signing capability
        const combined = data + attestationQuote + Date.now();
        return Buffer.from(combined).toString("base64");
    }
    async verifySignature(data, signature, attestationQuote) {
        try {
            // Placeholder verification - implement proper signature verification
            const decoded = Buffer.from(signature, "base64").toString();
            return decoded.includes(data) && decoded.includes(attestationQuote);
        }
        catch {
            return false;
        }
    }
    verifyAttestation(attestation) {
        // Basic attestation validation - implement proper Intel attestation verification
        return (attestation.quote.length > 0 &&
            attestation.rtmrs.length > 0 &&
            attestation.timestamp instanceof Date &&
            attestation.verified);
    }
    /**
     * Get TEE client status and health information
     */
    async getStatus() {
        try {
            // Check if TEE is reachable
            const healthy = await this.client.isReachable();
            return {
                healthy,
                endpoint: this.config.endpoint,
                features: {
                    attestation: this.config.enableAttestation,
                    keyDerivation: this.config.enableKeyDerivation,
                    signatures: this.config.enableSignatures,
                },
                lastAttestation: healthy ? new Date() : undefined,
            };
        }
        catch (error) {
            return {
                healthy: false,
                endpoint: this.config.endpoint,
                features: {
                    attestation: this.config.enableAttestation,
                    keyDerivation: this.config.enableKeyDerivation,
                    signatures: this.config.enableSignatures,
                },
            };
        }
    }
}
exports.TEEClient = TEEClient;
/**
 * TEE-enabled agent wrapper
 * Provides a simplified interface for agents to use TEE capabilities
 */
class TEEAgent {
    constructor(agentId, teeConfig) {
        this.agentId = agentId;
        this.teeClient = new TEEClient(teeConfig);
    }
    /**
     * Execute an operation securely within TEE
     */
    async executeSecurely(operation, options) {
        const agentUserData = `${this.agentId}-${options?.attestUserData || "default"}`;
        return this.teeClient.executeSecure(operation, {
            ...options,
            attestUserData: agentUserData,
        });
    }
    /**
     * Generate agent-specific attestation
     */
    async generateAgentAttestation() {
        const userData = `agent-${this.agentId}-${Date.now()}`;
        return this.teeClient.generateAttestation(userData);
    }
    /**
     * Create secure communication channel for this agent
     */
    async createSecureChannel() {
        return this.teeClient.createSecureChannel();
    }
    /**
     * Get TEE status for this agent
     */
    async getStatus() {
        return this.teeClient.getStatus();
    }
}
exports.TEEAgent = TEEAgent;
